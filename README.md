# 구현 범위 설명

기본적으로 모든 기능은 아래 조건들에 대해 구현을 했습니다.

1. 카테고리별로 최저가격인 브랜드와 가격, 총액 조회
2. 단일 브랜드로 전체 카테고리 구매 시 총액의 최저가 브랜드와 가격 조회
3. 특정 카테고리에서 최저가/최고가 브랜드와 가격 조회
4. 브랜드 및 상품을 추가, 변경, 삭제

1, 2, 3 번에 해당하는 **카테고리별 최저가, 단일 브랜드로 최저가, 특정 카테고리의 최저가/최고가 에 해당하는 데이터**는 데이터 조회에 필요한 컬럼에 인덱스를 적용했습니다.
또, 쌓인 데이터가 많아지게되면 쿼리의 최적화 만으로는 해결이 안될 수 있기 때문에 최초조회 혹은 새로운 상품 등록/수정 시에 캐시를 저장/업데이트 합니다.
캐시가 한 번 저장되면 상품 추가 혹은 가격 수정같이 재 계산이 필요한 경우 외에는 변경되지 않는 데이터기 때문에 캐시를 활용해서 조회 성능을 향상시킬 수 있습니다.

수정 대상 상품이 기존에 최저가로 캐시되어있을 떄 변경할 가격이 기존 최저가보다 작거나 동일할 경우 캐시에 반영합니다.
해당 최저가보다 큰 가격으로 변경할 때에는 캐시를 제거합니다.
가격 수정작업을 마무리하고 응답을 줘야하는데 새로운 최저가를 계산해서 캐시를 저장하느라 트랜잭션이 길어지는 걸 방지하고자 가격이 기존보다 큰 경우는 캐시 제거로 구현을 했습니다.

삭제도 마찬가지로 삭제 조건에 부합하다면 빠르게 삭제 처리를 해야하는데 삭제할 상품이 캐시에 적용된 데이터라면 모든 데이터를 다시 한 번 조회 후 각 조건 별로 캐시를 다시 업데이트 해야합니다.
삭제를 빠르게 처리하기 위해 현재는 캐시에 적용된 데이터라면 일단 해당하는 캐시를 비우고 이후 조회나 등록/수정 요청이 새로 들어오면 다시 캐시를 쌓게 됩니다.

해당 부분을 백그라운드 처리하는 방법을 사용할 수도 있지만 비동기 작업 관리, 실패 시에 failover 처리 등 고려할 조건이 많기 때문에 현재는 캐시를 비우는 방식으로 구성했습니다.

캐시 기능은 외부 저장소를 사용하지 않고 서버에서 HashMap 으로 인메모리 저장소를 구현했습니다.
Cache 라는 인터페이스를 활용해서 HashMap 인메모리 구현체를 구현했습니다.
이 방식의 장점은 캐시 저장소(Redis 와 같은 외부 저장소 포함)를 변경할 경우 Cache 인터페이스의 새로운 구현체를 추가 후 적용만 해준다면 캐시 저장소를 변경할 수 있습니다.

# 코드 빌드 방법

```./gradlew build```

# 테스트 코드 실행 방법

```./gradlew test```

# 서버 애플리케이션 실행 방법

```./gradlew bootRun```

# 기타 추가 정보

- 테스트 fixture 는 pdf 예시 데이터를 참고했습니다.
